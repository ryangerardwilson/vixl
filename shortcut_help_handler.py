from typing import List


class ShortcutHelpHandler:
    @staticmethod
    def get_lines() -> List[str]:
        return [
            "Shortcuts",
            "",
            "Global",
            "  Ctrl+C / Ctrl+Q - exit",
            "  q (df focus) - exit",
            "  Ctrl+S (df) - save",
            "  Ctrl+T (df) - save & exit",
            "  ? - show shortcuts",
            "",
            "Overlay (output)",
            "  Esc / q / Enter - close",
            "  j / k - scroll",
            "  Ctrl+J / Ctrl+K - half-page down/up",
            "  ,j / ,k - bottom/top",
            "",
            "Command bar",
            "  : (from df) - enter",
            "  Example: :df.info() (and other df.* commands)",
            "  Enter - execute",
            "  Esc - cancel",
            "  Ctrl+P / Ctrl+N - history prev/next",
            "  Backspace, Left/Right, Home/End - edit/move",
            "  Emacs-style: Alt+F/B (word fwd/back), Ctrl+W (delete word), Ctrl+U (kill to start), Ctrl+H/D (move left/right), Ctrl+A/E (line start/end)",
            "",
            "DF normal",
            "  (Numeric prefixes) h/j/k/l, Ctrl+J/K/H/L, ,ira/irb, ,dr",
            "  h / j / k / l - move",
            "  H / L - previous/next sheet",
            "  Ctrl+J / Ctrl+K - jump ~5% rows down/up",
            "  Ctrl+H / Ctrl+L - jump ~20% cols left/right",
            "  : - open command bar",
            "  i - edit current cell in vim (current terminal)",
            "  ,conf - open config in vim (reloads on exit)",
            "  x - clear current cell",
            "  , i r a - insert row above",
            "  , i r b - insert row below",
            "  , d r - delete row",
            "  , i c a - insert column after (prompt name + dtype)",
            "  , i c b - insert column before (prompt name + dtype)",
            "  , d c - delete column",
            "  , r n c - rename column",
            "  ,xr - expand/collapse current row",
            "  ,xar - expand/collapse all rows",
            "  ,xc - collapse all expansions",
            "  u - undo",
            "  r - redo",
            "  . - repeat last change (not for column ops or command bar)",
            "  , h - go to first column",
            "  , l - go to last column",
            "  , j - go to last row",
            "  , k - go to first row",
            "  , y a - copy df to clipboard (TSV)",
            "  , y c - copy current cell to clipboard",
            "  , p j - preview current cell as pretty JSON (read-only Vim)",
            "  ? - shortcuts",
            "",
            "Save prompt",
            "  Enter - save (requires .csv, .parquet, .xlsx, or .h5)",
            "  Esc - cancel",
            "  Backspace, Left/Right, Home/End - edit path",
            "",
            "Column prompt",
            "  Enter - confirm name/dtype",
            "  Esc - cancel",
            "  Backspace, Left/Right, Home/End - edit",
            "",
            "Loading screen",
            "  Ctrl+Q - abort loading",
            "",
            "##################################################################",
            "# Top 11 Things to Inspect the First Time You Access a Dataframe #",
            "##################################################################",
            "",
            "# 1. Columns, data types, schema, and sampling",
            "",
            "    df.columns",
            "    df.dtypes",
            "    df.info()  # dtypes and non-null counts",
            "    df.shape",
            "    df.head()",
            "    df.col_name[row_index]  # extract a cell",
            "    df.sample(5)",
            "    df.col_name.sample(20)",
            "    df.sample().T  # transpose any random row",
            "    pd.set_option('display.max_rows', 100)",
            "    df.tail()",
            "    df.col_name.nunique()",
            "    df.col_name.unique()",
            "    df['col'] = df.col.astype('datetime64[ns]')",
            "    df.col.dt.year.unique()",
            "    df.sort_values(by='col', ascending=False)",
            "    row_condition = df.assigned_col.notna()",
            "    df[['mobile', 'account_id', 'assigned', 'otp']][row_condition]",
            "    corr_matrix = df.corr(numeric_only=True)",
            "",
            "# 2. Duplicate rows & subset",
            "",
            "    df.duplicated().sum()",
            "    df.duplicated(subset=['id', 'date']).sum()",
            "",
            "# 3. Missing values",
            "",
            "    df.isnull().sum()",
            "    df.isnull().mean() * 100",
            "    df = df[df.datetime_col.notna()]",
            "",
            "# 4. Primary key",
            "",
            "    df.set_index(['col1', 'col2'], verify_integrity=True)",
            "    # or: df.drop_duplicates(subset=['col1', 'col2'])",
            "",
            "# 5. Relative distribution & frequencies",
            "",
            "    pd.crosstab(df.user_id, df.category)",
            "    pd.crosstab(df.user_id, df.category, normalize='index')",
            "",
            "# 6. Value counts",
            "",
            "    df.col.value_counts()",
            "    df[['categorical_col_1', 'categorical_col_2']].value_counts()",
            "    df.groupby('col').size()",
            "    df.groupby(['col1', 'col2']).size()",
            "",
            "# 7. Summary stats",
            "",
            "    df.describe(include='all')",
            "    df.describe(include='all').loc['count'].T",
            "",
            "# 8. Quantile analysis",
            "",
            "    cut_off = df.probs.quantile(0.90)",
            "    df['meets_cutoff'] = np.where(df.probs > cut_off, 1, 0)",
            "    print(df.meets_cutoff.value_counts())",
            "",
            "# 9. Quantile distribution analysis",
            "",
            "    df.duration_hours_col.quantile([i/10 for i in range(0, 11)]).round(2)",
            "",
            "# 10. Filter rows & columns",
            "",
            "    row_condition = df.assigned_col.notna()",
            "    df[['mobile', 'account_id', 'assigned', 'otp']][row_condition]",
            "",
            "# 11. Correlation matrix",
            "",
            "    corr_matrix = df.corr(numeric_only=True)",
        ]
